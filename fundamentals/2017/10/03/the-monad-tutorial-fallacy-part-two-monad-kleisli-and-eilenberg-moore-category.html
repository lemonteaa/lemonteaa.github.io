<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>The Monad Tutorial Fallacy, Part Two: Monad, Kleisli and Eilenberg-Moore Category</title>
  <meta name="description" content="(Go to Part 1 of this series) In part 2 of this series we explain the technical core of the theory of Monad. Of central importance is the attempt to provide ...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://lemonteaa.github.io/fundamentals/2017/10/03/the-monad-tutorial-fallacy-part-two-monad-kleisli-and-eilenberg-moore-category.html">
  <link rel="alternate" type="application/rss+xml" title="(into tech :lemontea)" href="/feed.xml">
  
  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-105429614-1', 'auto');
  ga('send', 'pageview');

</script>
  

  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
	<div>
		<a id="avatar" href="/"></a>
	</div>
    <a class="site-title" href="/">(into tech :lemontea)</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/projects/">Projects</a>
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">The Monad Tutorial Fallacy, Part Two: Monad, Kleisli and Eilenberg-Moore Category</h1>
    <p class="post-meta">
      <time datetime="2017-10-03T20:36:00+08:00" itemprop="datePublished">
        
        Oct 3, 2017
      </time>
      
      
        • <a href="https://lemonteaa.github.io/fundamentals/2017/10/03/the-monad-tutorial-fallacy-part-two-monad-kleisli-and-eilenberg-moore-category.html#disqus_thread">0 Comments</a>
      
	</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>(Go to <a href="/fundamentals/2017/08/28/the-monad-tutorial-fallacy-part-one-introduction-prequel.html">Part 1</a> of this series)</em></p>

<p>In part 2 of this series we explain the technical core of the theory of Monad. Of central importance is the attempt to provide algebraic interpretation of everything, as well as to convert things into suitably algebraic structures. We will also revisit this issue at an arguably “better” (but more advanced) angle in part 5.</p>

<p>While the picture for an adjunction is relatively clear, it suffers from needing to work with two categories at the same time. Monad fixes this by composing the left and right adjoint functors into an endofunctor <script type="math/tex">T = G \circ F</script>, <script type="math/tex">T: \mathcal{C} \rightarrow \mathcal{C}</script> over a single category. An additional advantage with this construction is that it is more algebraic as it is now composable: we can iterate <script type="math/tex">T</script> to get <script type="math/tex">T^2</script>, <script type="math/tex">T^3</script> etc for example. <!--more--><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p>

<h2 id="on-the-benefit-of-being-algebraicfunctional">On the benefit of being Algebraic/Functional</h2>
<p>It is perhaps appropriate at this point to pontificate on what does it means to be “algebraic”, and why do we obsesses over it, before proceeding further on the details. From my armchair philosophical perspective, being “algebraic” simply mean having a system of rules for manipulating symbols. But this “definition” is obviously wrong, for with this requirement the whole of pure mathematics at the very least qualifies! (All math are built from logic, and formal logic is just such a system of rules, albeit a bit more complicated than arithmetic) What distinguishes algebra from other such formal system is an intrinsic quality that it is easy and convenient to use.</p>

<p>But “easy” is subjective. And there seems to be more than one kind of feature that contribute to this elusive quality. These features include:</p>

<ul>
  <li>The rules and system should be as Context-free as possible, so that operations can be liberally applied, and so that a piece of operation/reasoning carried out somewhere can be taken and re-applied anywhere else
    <ul>
      <li>i.e. Equational Reasoning</li>
      <li>And in other words things should be reusable.</li>
    </ul>
  </li>
  <li>Composability. (Excuse my circular reasoning) It should be possible to chain functions together and if these functions are expressed with certain specific structures in mind, these structures should be preserved after composition.
    <ul>
      <li>Moreover, it should ideally have the Compositionality property - the meaning of a composed function should be derivable from the meaning of the individual functions alone.</li>
      <li>What they imply are that you have an easy way to build larger structures out of smaller one, while controlling (semantic) complexity.</li>
    </ul>
  </li>
</ul>

<p>If you are a programmer, you may find this list suspiciously familiar even though you may have forgotten all the math since you’re done with high school. Basically they are just the benefits of functional programming: pure functions are composable, safe, reusable, and easy to reason about and understand.</p>

<h2 id="defining-monad-is-a-dangerous-affair">Defining Monad is a Dangerous Affair</h2>
<p>If one dig around a bit in Haskell’s community, one can easily see how this is a topic laden with traps, controversies, and a sea of confused/perplexed beginners. There is an active advise against posting new Monad tutorials. There is a trail of <a href="https://wiki.haskell.org/Monad_tutorials_timeline">past attempts</a> at such tutorials. There is a post in the wiki specifically to debunk what <a href="https://wiki.haskell.org/What_a_Monad_is_not">Monad is not</a> and notwithstanding such effort, it is (in this author’s opinion) next to impossible to eradicate those “wrong” definitions, not even in principle. Oh and if you try to read Monad tutorial (like this one), you will find out that everyone’s definition is <a href="http://www.codecommit.com/blog/ruby/monads-are-not-metaphors">different</a>. <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p>

<p>That’s quite a downer, to put it mildly. Why? <sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup></p>

<p><em>&lt;begin rant&gt;</em></p>

<p>Please bear with me as I do a second round of philosophizing and go meta. Defining real world, nebulous concepts is almost always messy (in contrast to the pristine one you get in pure math). They are typically complicated. Have multiple facets. Have multiple possible perspectives to look at that are mostly equally reasonable within their own frameworks. (Or, at least, no one managed to convince anyone else in case of a conflict) Have multiple layers of understanding possible to attain. Ad Nauseum.</p>

<p>With this kind of stuff, saying any particular definition is “wrong” is meaningless without defining “wrongness” within a suitable context. Say in a hypothetical (i.e. oversimplified) situation there is a hierarchy of definitions possible, from the most specific to the most general. Is the specific one wrong because it fails to capture the full range of possibilities, or the general one wrong because it is utterly useless for application? Sometimes I think we geeks and nerds need to stop pretending math/logic/programming is the solo, absolute standard of truth in all domains. Just go read some (ok, any) sociology texts and resists the temptation to call everything in it bullshit. (except some toxic part of postmodernism maybe?)</p>

<p><em>&lt;end rant&gt;</em></p>

<p>But it seems irresponsible to go on without any definition at all besides the formal one. So, in light of the sensitiveness of this issue, I will tread carefully and give more than one definitions.</p>

<p>A Monad is not about statefulness/impurity. It’s also not about explicit sequencing of execution. They are, however, possible applications of Monad. (Among others)</p>

<h3 id="most-general-definition-i-can-think-of">Most general definition I can think of</h3>
<p>(Inspired by this <a href="https://www.reddit.com/r/haskell/comments/68fb19/monad_tutorial_no_57005/dgynjik/">brilliant comment</a> over there)</p>

<blockquote>
  <p>Monad is a mathematical theory that can be used to extend the semantics of a programming language in a principled manner, provided the extra structures admits an algebraic formulation.</p>
</blockquote>

<p>Because of this I believe the closest comparison one can make is versus Macro in the Lisp family of language <sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>. At least they are roughly at the same conceptual level of abstraction.</p>

<p>One should also be careful to distinguish between Monad-as-a-concept, versus how it is implemented in actual languages.</p>

<p>Monad is not a <a href="http://lambda-diode.com/programming/monads-are-a-class-of-hard-drugs">silver bullet</a> nor black magic. It is, in the final analysis, up to you to decide what to do with it.</p>

<h3 id="operational-definition---full-buy-in">Operational definition - Full buy in</h3>
<blockquote>
  <p>A Monad is a contract between the programmer and the language. Programmer agrees to structure their program in a particular form, and to supply proof of the Monad axiom themselves, outside of the program. In return, the language promises automatic guarantee of some properties of the program.</p>
</blockquote>

<p>But asking a programmer to write proof is scary, horrible stuff. Monad is thoughtful in this regard:
As there is multiple equivalent formulation of Monad, one have the option to choose which one to work on.
The math statements that one is actually required to prove is also algebraic/equational in nature, so it is in principle possible to just compute/derive with lambda calculus blindly and hope that the equations just line up, as opposed to requiring professional grade mathematical literacy.</p>

<h3 id="operational-definition---partial-buy-in">Operational definition - Partial buy in</h3>
<p>In case even that is too much, it is also possible to write code in a monadic style. In this case one adopts patterns inspired by the Monad, but refrain from (actively) doing the proof or making their code completely compliant to the requirement. One may still gain some benefits, but foregoes the mathematical guarantee offered by the theory.</p>

<h2 id="formal-definition-of-monad">Formal definition of Monad</h2>
<p>For delicate, highly abstract entity like Monad (as well as other heavily categorical construct, and especially things involving <a href="https://ncatlab.org/nlab/show/higher+category+theory">higher category</a>), one can argue that the only safe way to grok it would be to look at the full, formal definition (otherwise one runs the risk of missing a “small” piece of the definition - which usually contains a “large” number of such pieces - that turns out to be crucial in unexpected place). But doing so come with the cost of things being opaque and complicated. While I may not be able to solve the “complicated” part (irreducible complexity, say), I have tried to deal with the first by presenting a mixture of motivation, discourse, supporting theories, etc.</p>

<p>Even so, we won’t try to understand Monad all in one go, preferring an iterative and indirect approach instead. We will provide a preliminary, algebraic understanding of Monad, only in the context of classical Mathematics (through the “Universal” example of Free algebra vs Forgetful Functor). In part 3 of this series we will give an interpretation within the context of raw vs structured computational model, alongside actual examples of Monad in programming, while in part 4 we will give alternative, equivalent formulation of Monad that admits an easier interpretation in the computational context. (Part 5’s purpose has been stated at the beginning of this article) Nonetheless, all these niceties depends on the core theory presented in this part.</p>

<p>The actual definition of <a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">Monad</a> is here (Don’t worry if you don’t get it all at once! The important thing in this part is actually the theory of Kleisli and Eilenberg-Moore Category since I don’t see them fully interpreted anywhere except for some handwaving. Just read on and stay tuned for part 3 - 5 :P ):</p>

<ul>
  <li>A Monad over a category <script type="math/tex">\mathcal{C}</script> is a triple <script type="math/tex">(T, \eta, \mu)</script> where <script type="math/tex">T</script> is a functor <script type="math/tex">\mathcal{C} \rightarrow \mathcal{C}</script>.
    <ul>
      <li>(for those not studying math: I must highlight that a functor when implemented in a programming language is actually two things: <script type="math/tex">T</script> here maps objects in <script type="math/tex">\mathcal{C}</script> to objects in <script type="math/tex">\mathcal{C}</script>, and <strong>also</strong> morphisms/function in <script type="math/tex">\mathcal{C}</script> to morphisms/function in <script type="math/tex">\mathcal{C}</script>, where the (co)domain object is also mapped. That is, <script type="math/tex">T</script> sends <script type="math/tex">f: X \rightarrow Y</script> into <script type="math/tex">Tf: TX \rightarrow TY</script>)</li>
    </ul>
  </li>
  <li><script type="math/tex">\eta</script> is the unit (sometimes called <code class="highlighter-rouge">return</code> in programming), which is a natural transformation from the identity functor to <script type="math/tex">\mathcal{C}</script>. More concretely for any object <script type="math/tex">X</script> in <script type="math/tex">\mathcal{C}</script>, we have a morphism/function <script type="math/tex">\eta_X: X \rightarrow TX</script>.</li>
  <li>And <script type="math/tex">\mu</script> is the “multiplication” / “algebraic operation” (called <code class="highlighter-rouge">join</code> or <code class="highlighter-rouge">flatten</code> in programming). It is also a natural transformation, this time from <script type="math/tex">T^2</script> to <script type="math/tex">T</script>. That is it is a polymorphic function from <script type="math/tex">T^2 X</script> to <script type="math/tex">TX</script>.
    <ul>
      <li>Notice that both <a href="https://en.wikipedia.org/wiki/Functor#Definition">functor</a> and <a href="https://en.wikipedia.org/wiki/Natural_transformation#Definition">natural transformation</a> obey certain constraints/equations/axioms, which are not listed here.</li>
    </ul>
  </li>
  <li>Finally, our <script type="math/tex">\eta</script> and <script type="math/tex">\mu</script> satisfies two additional coherence conditions, expressed via commutative diagrams:</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\array{
    \phantom{\mu T} T^3 & \stackrel{T \mu}\longrightarrow & T^2 \\
    ^{\mu T}\downarrow  &                                 & \downarrow^\mu \\
    \phantom{\mu T} T^2 & \stackrel{\mu}\longrightarrow   & T
}
\qquad
\array{
	\phantom{T \eta} T   & \stackrel{\eta T}\longrightarrow & T^2 \\
	^{T \eta} \downarrow & \searrow^\text{id}               & \downarrow^\mu \\
	\phantom{T \eta} T^2 & \stackrel{\mu}\longrightarrow    & T
} %]]></script>

<p>As many people/articles/tutorials have observed, these laws look a lots like the identity and associativity law of an algebra (say a group):</p>
<ul>
  <li>(Identity) For all <script type="math/tex">x</script>, <script type="math/tex">0 + x = x + 0 = x</script>.</li>
  <li>(Associativity) For all <script type="math/tex">x, y, z</script>, <script type="math/tex">x + (y + z) = (x + y) + z</script>.</li>
</ul>

<p>We will in time comes to a fuller understanding of this point, through multiple rounds of seeing this play out in different level of abstractions.</p>

<p>Before moving on, here’s a technical aside (included since we’ll assume knowledge of this bit when doing proofs later on in this post): the notation mixing functor and natural transform above is a shorthand. Suppose <script type="math/tex">\epsilon: F \Rightarrow G</script> is a natural transform from <script type="math/tex">F</script> to <script type="math/tex">G</script>, and let <script type="math/tex">H</script> be another functor. Then <script type="math/tex">H\epsilon</script> means applying the functor <script type="math/tex">H</script> to the arrow <script type="math/tex">FX \stackrel{\epsilon_X}\longrightarrow GX</script> to get <script type="math/tex">H(FX) \stackrel{H \epsilon_X}\longrightarrow H(GX)</script>. Meanwhile, <script type="math/tex">\epsilon H</script> actually means the natural transform applied at the object <script type="math/tex">HX</script> instead of <script type="math/tex">X</script>, i.e. <script type="math/tex">F(HX) \stackrel{\epsilon_{HX}}\longrightarrow G(HX)</script>.</p>

<p>We still need to connect this formal definition to our earlier motivation of composing adjoint functors. In fact there is a general construction to get a monad from any adjoint functors. <script type="math/tex">T</script> is just <script type="math/tex">G \circ F</script> as mentioned before. The unit is just the unit in the adjunction. The join operation is obtained by applying the counit to <script type="math/tex">T^2</script>, that is: <script type="math/tex">T^2 = (GF)(GF) = G(FG)F \longrightarrow G \operatorname{1}_{\mathcal{D}} F = GF = T</script>. (While this general construction works, I can’t get a satisfactory interpretation in the context of computational model. So I’ll take a detour and interpret a different, but equivalent formulation of Monad in part 4)</p>

<p>Now let’s interpret this using the example of free algebra vs forgetful functors. <script type="math/tex">T</script> simply map any set <script type="math/tex">X</script> to the underlying set of its free algebra <script type="math/tex">F(X)</script>, and maps function between set to the naturally induced map between their corresponding free algebra, as usual. The unit provides the embedding of the original set <script type="math/tex">X</script> into the free algebra(‘s underlying set). The really non-trivial part is the join operation. Notice that <script type="math/tex">T^2X</script> is a set consisting of algebraic expression of algebraic expression over <script type="math/tex">X</script>. If this is befuddling, we can also say that it is an algebraic expression where one layer of variable definition is allowed. For example:
If <script type="math/tex">X = \{ x, y, z \}</script>, then let <script type="math/tex">p = 2x+1, q=x-y+3z, r=y^2 + xz</script>, and let the final expression be <script type="math/tex">p^2 - q + 2r</script>.</p>

<p>Now there is an obvious way to simplify this: just (partially) evaluate it by substitution: <script type="math/tex">(2x+1)^2 - (x-y+3z) +2(y^2 + xz) = \ldots</script></p>

<p>We can see how this is related to the general construction of the join operation: Recalling that an expression evaluator is possible in any algebra (and given by the counit), a substitution evaluator is really just a plain evaluator over the free algebra <script type="math/tex">F(X)</script>, so we have <script type="math/tex">FGF(X) \longrightarrow F(X)</script>. Now simply apply forgetful functor on both sides.</p>

<h2 id="kleisli-category">Kleisli Category</h2>
<p>We use monad in practise instead of adjunction when programming because it is difficult to specify an entirely new computational model, while it is “easy” (in the sense of not having to leave your current programming environment) to implement things within the current computational model. While our conceptual picture is that of constructing/deriving a monad from an adjunction, we can still ask the converse question: does every monad arise from/implies an adjunction?</p>

<p>Happily, it turns out the answer is a resounding “Yes”. In fact there is a family of possible adjunctions that compose to the same monad. Even more luckily, there is both a minimal and maximal such adjunctions, and they are the minimal, <a href="https://en.wikipedia.org/wiki/Kleisli_category">Kleisli category</a> consisting of just the free algebra, versus the maximal, <a href="https://en.wikipedia.org/wiki/F-algebra">Eilenberg-Moore category</a> of all algebra. We will look at both in turns.</p>

<p>Suppose that we just assume the existence of any such adjunction, without knowing what the other category <script type="math/tex">\mathcal{D}</script> is (nor the individual functors <script type="math/tex">F</script> or <script type="math/tex">G</script>). Further assume that they are really just some form of Free algebra/Forgetful functors. At the very least, <script type="math/tex">\mathcal{D}</script> must contain the image of <script type="math/tex">F</script> over <script type="math/tex">\mathcal{C}</script>, which are all the free algebras. Since we don’t really know what <script type="math/tex">F</script> is, we will just let any object <script type="math/tex">X</script> in <script type="math/tex">\mathcal{C}</script> stands for an unknown object <script type="math/tex">F(X)</script>. <sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> Hence we can let the set of objects in <script type="math/tex">\mathcal{D}_{\text{min}}</script> be just all the objects in <script type="math/tex">\mathcal{C}</script>.</p>

<p>Now how about the morphisms? <em>Prima facie</em>, they should really be just the algebra’s homomorphisms, i.e. <script type="math/tex">{\operatorname{Hom}}_{\mathbf{Alg}}(FX, FY)</script>, and composition of morphism is just ordinary composition of function. However we can’t do that since we don’t directly know <script type="math/tex">F</script>. Instead we need to do so indirectly by expressing them in terms of things we have direct access to only. So appealing to the Hom-adjunction property of an adjunction, we have that that set is naturally isomorphic to <script type="math/tex">{\operatorname{Hom}}_{\mathbf{Set}}(X, UFY) = {\operatorname{Hom}}_{\mathbf{Set}}(X, TY)</script>, and we can just let this latter set be the definition of morphisms between <script type="math/tex">X</script> and <script type="math/tex">Y</script> in <script type="math/tex">\mathcal{D}</script>.</p>

<p>A challenge that remains is to define composition of morphisms. Per the reasoning/interpretation for the Hom-Set adjunction we talked about in <a href="/fundamentals/2017/08/28/the-monad-tutorial-fallacy-part-one-introduction-prequel.html">Part 1</a>, given an arrow <script type="math/tex">X \longrightarrow TY</script> it should be possible to uniquely extend it into a morphism <script type="math/tex">TX \longrightarrow TY</script>. Then we can just compose as usual: <script type="math/tex">X \longrightarrow TY \longrightarrow TZ</script> is an arrow from <script type="math/tex">X</script> to <script type="math/tex">TZ</script>, which fits the representation of morphism in <script type="math/tex">\mathcal{D}_{\text{min}}</script>. In programming this extension operation is called a <code class="highlighter-rouge">bind</code> (After switching order of arguments if necessary and using the curried form). <sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup></p>

<p>It turns out that bind can be expressed in terms of a Monad by sending <script type="math/tex">X \stackrel{\phi}\longrightarrow TY</script> into <script type="math/tex">TX \stackrel{T\phi}\longrightarrow T^2 Y \stackrel{\mu_Y}\longrightarrow TY</script>. We can prove that this is correct, namely, that the result of extension defined this way, is the same as applying the forgetful functor to the same morphism <script type="math/tex">\phi</script> represented as an honest algebra homomorphism <script type="math/tex">{\operatorname{Hom}}_{\mathbf{Alg}}(FX, FY)</script>.</p>

<p>First note that the extended morphism has at least one <script type="math/tex">T</script> throughout ( <script type="math/tex">UFX \stackrel{UF\phi}\longrightarrow (UF)(UF)Y \stackrel{\mu_Y}\longrightarrow UFY</script>), so we can strip the outer <script type="math/tex">U</script> (due to functor’s law), and then it suffices to show that the morphism <script type="math/tex">FX \stackrel{F\phi}\longrightarrow FUFY \stackrel{\eta_{FY}}\longrightarrow FY</script> is <script type="math/tex">\phi</script> mapped by the natural isomophism between <script type="math/tex">{\operatorname{Hom}}_{\mathbf{Set}}(X, UFY)</script> and <script type="math/tex">{\operatorname{Hom}}_{\mathbf{Alg}}(FX, FY)</script>. Now note that by category theory, the counit <script type="math/tex">\eta_{FY}</script> is really just the identity on <script type="math/tex">UFY</script> mapped through the natural isomorphism, and that by naturality’s commutative diagram, pre-composing it with <script type="math/tex">F\phi</script> is then the same as just pre-composing <script type="math/tex">\text{id}_{UFY}</script> with <script type="math/tex">\phi</script> (which is then still <script type="math/tex">\phi</script>), and then applying the natural isomorphism, and so we are done.</p>

<p>If this is too dense, a rough sketch of the proof is that the counit (expression evaluator) extend to the identity, and that since extension is basically just the natural isomophism of an adjunction, we can indirectly get what we want by applying the counit and relying on the “commutative” property of extension.</p>

<p>For the case of actual free algebra, what this operation amount to is to first induce a map from the free algebras generated by <script type="math/tex">X</script> and <script type="math/tex">TY</script> by considering <script type="math/tex">\phi</script> as just an honest map between sets (ignoring the structures in <script type="math/tex">TY</script>), and then collapse the nested algebraic expression that results by substitution.</p>

<p>Before moving on we want to check that composition defined this way is associative. Since the composition is built out of the extension operator, we only need to check the following:
<script type="math/tex">(g^* \circ f)^* = g^* \circ f^*</script> (Which can be seen as an indirect form of idempotency. It cannot be stated directly because the extension operator cannot be applied to the same function twice)</p>

<p>We compute</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray} 
(g^* \circ f)^* &=& (X \stackrel{f}\longrightarrow TY \stackrel{g^*}\longrightarrow TZ)^* \\
&=& T \left( X \stackrel{f}\longrightarrow TY \stackrel{g^*}\longrightarrow TZ \right) \stackrel{\mu_Z}\longrightarrow TZ \\
&=& TX \stackrel{Tf}\longrightarrow T^2 Y \stackrel{Tg^*}\longrightarrow T^2 Z \stackrel{\mu_Z}\longrightarrow TZ
\end{eqnarray} %]]></script>

<p>Now since <script type="math/tex">g^*</script> is <script type="math/tex">TY \stackrel{Tg}\longrightarrow T^2 Z \stackrel{\mu_Z}\longrightarrow TZ</script>, <script type="math/tex">Tg^*</script> is <script type="math/tex">T^2 Y \stackrel{T^2 g}\longrightarrow T^3 Z \stackrel{T \mu_Z}\longrightarrow T^2 Z</script>.</p>

<p>We can use the associativity of <script type="math/tex">\mu</script>, and then the naturality of <script type="math/tex">\mu</script>, to change to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
&& TX \stackrel{Tf}\longrightarrow \left( T^2 Y \stackrel{T^2 g}\longrightarrow T^3 Z \stackrel{T \mu_Z}\longrightarrow T^2 Z \right) \stackrel{\mu_Z}\longrightarrow TZ \\
&=& TX \stackrel{Tf}\longrightarrow T^2 Y \stackrel{T^2 g}\longrightarrow \left( T^3 Z \stackrel{\mu_{TZ}}\longrightarrow T^2 Z \stackrel{\mu_Z}\longrightarrow TZ \right) \\
&=& TX \stackrel{Tf}\longrightarrow \left( T^2 Y \stackrel{\mu_Y}\longrightarrow T Y \stackrel{Tg}\longrightarrow T^2 Z \right) \stackrel{\mu_Z}\longrightarrow TZ \\
&=& g^* \circ f^*
\end{eqnarray} %]]></script>

<p>as desired.</p>

<p>We can also reconstruct <script type="math/tex">F</script> and <script type="math/tex">G</script> from the monad <script type="math/tex">T</script> using Kleisli Category, and it is mostly common sense. <script type="math/tex">F</script> should just send any object in <script type="math/tex">\mathcal{C}</script> to the same object in <script type="math/tex">\mathcal{D}_{\text{min}}</script> (due to the way we relabel things). Morphisms in <script type="math/tex">\mathcal{C}</script> can be embedded in <script type="math/tex">\mathcal{D}_{\text{min}}</script> by just composing with the unit, aka <script type="math/tex">X \stackrel{f}\longrightarrow Y \stackrel{\mu_Y}\longrightarrow TY</script>. (Check that this is a functor!) Similarly, to forget things, <script type="math/tex">X</script> in <script type="math/tex">\mathcal{D}_{\text{min}}</script>, which represent <script type="math/tex">F(X)</script>, should be sent to <script type="math/tex">UF(X) = TX</script>. Morphisms in <script type="math/tex">\mathcal{D}_{\text{min}}</script>, say <script type="math/tex">X \stackrel{g}\longrightarrow TY</script>, will need to sent to some function of type <script type="math/tex">TX \longrightarrow TY</script>. So we just apply the extension operator since it is unique anyway.</p>

<h2 id="eilenberg-moore-category">Eilenberg-Moore Category</h2>
<p>At the opposite extreme, suppose we want to construct the category of all “algebra”. The challenge here is that we need to specify it without referring to anything internal to the objects itself (say, the addition operation in abelian groups), since for the construct to be general we must not make any assumption on what kinds of objects they are actually. Instead we can try to appeal to the interrelationship between objects. This kind of approach to generalizing things beyond their original context/example is known as “categorification” in mathematics.</p>

<p>So an algebra is just a set with all the algebraic operation specified over that set. Per the remarks above we are not allowed to refer to the actual algebra, although we can refer to the underlying sets. (As they are in category <script type="math/tex">\mathcal{C}</script>) Recalling what we said in <a href="/fundamentals/2017/08/28/the-monad-tutorial-fallacy-part-one-introduction-prequel.html">part 1</a>, a cunning trick to recover the algebra is to specify an expression evaluator instead. (This works because expression encompass and generalize algebraic operation. For example, to fully specify <script type="math/tex">+</script>, it suffices to know the value of the expression <script type="math/tex">a + b</script> where <script type="math/tex">a</script> and <script type="math/tex">b</script> can range over everything in <script type="math/tex">X</script>) This we can do: objects in our category <script type="math/tex">\mathcal{D}_\text{max}</script> is just an arrow <script type="math/tex">TX \stackrel{\alpha}\longrightarrow X</script>, where <script type="math/tex">X</script> is in <script type="math/tex">\mathcal{C}</script>. Here <script type="math/tex">X</script> is the underlying set, <script type="math/tex">TX</script> is a free algebra whose elements are all the expressions, and the morphism is then the evaluator (it maps expression over <script type="math/tex">X</script> to value in <script type="math/tex">X</script> again).</p>

<p>However, the formulation here is too loose: we must somehow ensure that the evaluator is valid, that it obey the algebra’s laws/axioms. Part of this work is already done by the free algebra construct hidden within <script type="math/tex">T</script>, since expressions that are provably identical using the axioms of the algebra are quotiented out (i.e. identified) in <script type="math/tex">F(X)</script>. The remaining part is a baggage brought on by the fact that <script type="math/tex">TX</script>, as a free algebra, has extra structures not present when we are just talking about the value of <script type="math/tex">a + b</script> (with <script type="math/tex">a</script> and <script type="math/tex">b</script> mere values and not expressions).</p>

<p>To do this we appeal to the monad, again applying the idea that expression generalize algebraic operation. Namely, we require the following diagram commutes:</p>

<script type="math/tex; mode=display">% <![CDATA[
\array{
	T^2 X            & \stackrel{T \alpha}\longrightarrow & TX \\
	\downarrow^{\mu} &                                    & \downarrow^{\alpha} \\
	TX               & \stackrel{\alpha}\longrightarrow   & X
}
\qquad
\array{
	X & \stackrel{\eta}\rightarrow  & TX \\
	  & {}_{\text{id}} \searrow     & \downarrow^{\alpha} \\
	  &                             & X
} %]]></script>

<p>What does it mean? Suppose we have an expression of expression. The two ways to evaluate it would be to either substitute then evaluate (monad join, followed by <script type="math/tex">\alpha</script>), or evaluate twice - evaluate the value of intermediate variables first, then evaluate the resulting expression. (<script type="math/tex">T \alpha</script> then <script type="math/tex">\alpha</script>) They should obviously be the same. As an example, let <script type="math/tex">u = x + 2y</script> and <script type="math/tex">v = y - z</script>. Suppose that <script type="math/tex">x = 3, y = 7, z = 1</script>. Then <script type="math/tex">u = 17, v = 6</script> and so <script type="math/tex">u + v = 23</script>. On the other hand <script type="math/tex">u + v = x + 3y - z</script>, so the evaluator have to map <script type="math/tex">x + 3y - z</script> to <script type="math/tex">23</script> (as this is not otherwise mandated since this expression is different from either <script type="math/tex">u</script> or <script type="math/tex">v</script>, and <script type="math/tex">TX \longrightarrow X</script> is just a map from set to set).</p>

<p>With the basic structure out of the way, specifying homomorphisms between algebra is actually pretty easy. Consider that a hom is a function between the underlying set which must also respect the algebraic structure. In ordinary algebra this is expressed through commutative diagrams for each algebraic operations. For instance:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
\stackrel{(a, b)}{G \times G}             @>+>> \stackrel{(a + b)}{G} \\
@V{(\phi, \phi)}VV                              @VV{\phi}V \\
\underset{(\phi(a), \phi(b))}{H \times H} @>+>> \underset{\phi(a + b) = \phi(a) + \phi(b)}{H}
\end{CD}</script>

<p>Because the structure of each algebra is already constrained by the requirement above, we can just naively generalize this diagram, turning the artificial <script type="math/tex">G \times G</script> into the more general set of expression <script type="math/tex">TX</script>:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
T(X)     @>{\alpha}>> X \\
@V{Tf}VV              @VVfV \\
T(Y)     @>{\beta}>>  Y
\end{CD}</script>

<p>It remains to show that this does indeed form a category, and the main work to do is to check the composition of morphisms. Well, we can just stack the commutative diagram together:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
T(X)     @>{\alpha}>> X \\
@V{Tf}VV              @VVfV \\
T(Y)     @>{\beta}>>  Y \\
@V{Tg}VV              @VVgV \\
T(Z)     @>{\gamma}>>  Z \\
\end{CD}</script>

<p>Recalling that our goal is to prove the outer square commutes, we can perform diagram chasing: first note that the arrows <script type="math/tex">X \stackrel{f}\longrightarrow Y \stackrel{g}\longrightarrow Z</script> is the same as <script type="math/tex">X \stackrel{g \circ f}\longrightarrow Z</script>, and by functor’s axiom we can apply <script type="math/tex">T</script> to this “equation” to get that the arrow on the left hand side can also be decomposed: <script type="math/tex">X \stackrel{T(g \circ f)}\longrightarrow Z</script> is the same as <script type="math/tex">X \stackrel{Tf}\longrightarrow Y \stackrel{Tg}\longrightarrow Z</script>. Then just apply the commutativity condition for the two inner squares to transform:</p>

<script type="math/tex; mode=display">(g \circ f) \circ \alpha = g \circ (f \circ \alpha) = g \circ \beta \circ Tf = \gamma \circ Tg \circ Tf = \gamma \circ T(g \circ f)</script>

<h2 id="full-circle-back">Full Circle Back</h2>
<p>Finally, as free algebra are also algebra, we want to see how the Kleisli category embed into the Eilenberg Moore Category. Well, the underlying set of a free algebra generated by <script type="math/tex">X</script> is just <script type="math/tex">TX</script>, so we need an arrow <script type="math/tex">T^2 X \longrightarrow TX</script>. The monad join fits the bill here (and not just because the signature match<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>) Why? Because algebraic operations in a free algebra is in fact defined by the substitution semantics. Anyway we still need to verify the conditions/diagrams for being an algebra. The first diagram is commutative because <script type="math/tex">\mu</script> is a natural transform. The second diagram is just the unit law of monad.</p>

<p>How about morphism? We need a representation that is of type <script type="math/tex">TX \longrightarrow TY</script> - which means for a morphism <script type="math/tex">\phi: X \longrightarrow TY</script> we should use its extension <script type="math/tex">\phi^*</script>. Then we should check that it is in fact a morphism in the Eilenberg-Moore Category:</p>

<script type="math/tex; mode=display">% <![CDATA[
\array{
	T^2 X                 & \stackrel{\mu}\longrightarrow   & TX \\
	\downarrow^{T^2 \phi} &                                 & \downarrow^{T \phi} \\
	T^3 Y                 & \stackrel{\mu T}{\cdots\cdots}  & T^2 Y \\
	\downarrow^{T \mu}    &                                 & \downarrow^{\mu} \\
	T^2 Y                 & \stackrel{\mu}\longrightarrow   & TY
} %]]></script>

<p>The diagram constructed from <script type="math/tex">\phi^*</script> is shown above (with the obvious step for decomposing <script type="math/tex">T(\phi^*)</script> omitted as it is the same as what we’ve seen before - just use the functor’s law). To prove that it commutes, connect the middle row with the morphism <script type="math/tex">\mu T</script>. Then the bottom square commutes by the multiplication law of monad, while the upper square commutes due to <script type="math/tex">\mu</script> being a natural transform. Then we’re done by performing the usual diagram chasing.</p>

<p>Incidentally, this provide an alternative proof that the extension operator is correct: as extension is unique, we only need to ensure that:</p>

<ol>
  <li>The extended morphism remains the same on <script type="math/tex">X</script></li>
  <li>It is a homomorphism on <script type="math/tex">\mathcal{D}</script> and not just <script type="math/tex">\mathcal{C}</script>.</li>
</ol>

<p>The argument above amount to showing 2. For 1, we precompose with the unit:
<script type="math/tex">% <![CDATA[
\begin{eqnarray}
&&X \stackrel{\eta}\longrightarrow TX \stackrel{T \phi}\longrightarrow T^2 Y \stackrel{\mu}\longrightarrow TY \\
&=& X \stackrel{\phi}\longrightarrow TY \stackrel{\eta}\longrightarrow T^2 Y \stackrel{\mu}\longrightarrow TY \text{(unit is natural)} \\
&=& X \stackrel{\phi}\longrightarrow TY.
\end{eqnarray} %]]></script></p>

<h2 id="one-more-thing">One more thing…</h2>

<p>Right when I’m doing the final editing I come across <a href="http://blog.sigfpe.com/2009/12/where-do-monads-come-from.html">this</a> and at a glance the approach it took looks similar to what I did here (free algebra/algebraic expression, that kind of stuff), although I took a pure math approach in case you’re too thick :P.</p>

<p><em>(Monad Series: To be continued…)</em></p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>This does not mean that the adjunction construct is not algebraic - in fact a Category can be thought of as a groupoid, where elements can be multiplied provided their domain/co-domain match. Then an ordinary group is just a groupoid with only one domain so that anything can be multiplied with anything.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>But I can’t resist the temptation to include a Matrix quote:</p>
      <blockquote>
        <p>The Matrix is everywhere. It is all around us. Even now, in this very room. You can see it when you look out your window or when you turn on your television. You can feel it when you go to work… when you go to church… when you pay your taxes. It is the world that has been pulled over your eyes to blind you from the truth.</p>

        <p>…</p>

        <p>Unfortunately, no one can be…told what the Matrix is. You have to see it for yourself.</p>

        <p>Morpheus, The Matrix (1999)</p>
      </blockquote>
      <p><a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>But fear not, for the Haskell community recognized this problem long ago (How can they not when you have endless waves of people asking about Monad?), and I think somewhere, nice and smart people are trying to find a better way. For example, see <a href="https://www.slideshare.net/linecorp/the-monad-fear">this presentation</a>.&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>But Haskell also has something similar - template. See <a href="https://www.reddit.com/r/haskell/comments/61r64w/what_does_the_free_monad_offer_that_macros_dont/">this</a> for an advocacy.&nbsp;<a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Those not coming from a math/abstract algebra background may find this strange. Rest assured it is a culturally standard practise in math. One of the very first thing you learn in university algebra is that the actual name/label given to things in a set doesn’t matter - so long as you always get the right things when called upon to. (In fact recall that the definition of a Category doesn’t really require looking into the <em>content</em> of an object) So using <script type="math/tex">X</script> instead of the actual <script type="math/tex">F(X)</script> doesn’t hurt - given such a label we can get back the real things, metaphorically, by applying the functor <script type="math/tex">F</script>.&nbsp;<a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>The naming here may look strange. It will look much more “natural” (no pun intended) when doing actual programming where we care about actually applying those functions.&nbsp;<a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>A gripe I have with the statically typed camp of programming, even for the sufficiently-advanced-type-that-offer-automatic-safety-guarantee, is that placing too much focus on the type risks crowding out my cognitive capacity to understand the actual semantics of a piece of code. It takes discipline to resist the temptation to consider a function correct just because the signature match.&nbsp;<a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  
    

  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://lemonteaa.github.io/fundamentals/2017/10/03/the-monad-tutorial-fallacy-part-two-monad-kleisli-and-eilenberg-moore-category.html';
      this.page.identifier = '/fundamentals/2017/10/03/the-monad-tutorial-fallacy-part-two-monad-kleisli-and-eilenberg-moore-category.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://lemontea-techblog.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <!--<h2 class="footer-heading">(into tech :lemontea)</h2>-->

    <div class="footer-col-wrapper">
      <div class="footer-col my-footer-col-1">
        <ul class="contact-list">
          <li>
            
              (into tech :lemontea)
            
            </li>
        </ul>
      </div>

      <div class="footer-col my-footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/lemonteaa"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">lemonteaa</span></a>

          </li>
          

          
		  
		  
          <li>
			<a href="mailto:lemontea.Tom@gmail.com"><span class="icon icon--email"><svg viewBox="0 0 16 16" width="16px" height="16px">
<g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1">
    <g
       id="g4187"
       transform="matrix(0.82252529,0,0,0.82252529,-254.40571,-324.97836)">
      <rect
         y="400.36658"
         x="311.20438"
         height="10"
         width="16"
         id="rect4164"
         style="fill:none;fill-opacity:1;stroke:#828282;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
      <path
         sodipodi:nodetypes="ccc"
         inkscape:connector-curvature="0"
         id="path4166"
         d="m 311.6,400.8622 7.9,4.9 7.5,-5"
         style="fill:none;fill-rule:evenodd;stroke:#828282;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:0;stroke-dasharray:none;stroke-opacity:1" />
      <path
         inkscape:connector-curvature="0"
         id="path4170"
         d="m 311.4,409.9622 4.7,-5.8"
         style="fill:none;fill-rule:evenodd;stroke:#828282;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
      <path
         sodipodi:nodetypes="cc"
         inkscape:connector-curvature="0"
         id="path4170-5"
         d="m 326.85,409.9622 -4.2,-6.1"
         style="fill:none;fill-rule:evenodd;stroke:#828282;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
    </g>
  </g>
</svg></span><span class="username">lemontea.Tom@gmail.com</span></a>

		  </li>
          
        </ul>
      </div>

      <div class="footer-col my-footer-col-3">
        <p>Site Generated by <a href="https://jekyllrb.com/">Jekyll</a> using customized version of the <a href="https://github.com/jekyll/minima">Minima</a> theme.</p>

      </div>
    </div>

  </div>

</footer>


<script id="dsq-count-scr" src="//lemontea-techblog.disqus.com/count.js" async></script>



  </body>

</html>
